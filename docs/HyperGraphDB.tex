\secrel{\hgdb}\secdown

Current binary version of \hgdb\ was integrated with binary \seco\ distribution,
so we don't need any special installation. Create new notebook
\emph{HyperGraphDB} in \seco\ and put this code from tutorial, which will be
create/open sample \hgdb\ database:

\bigskip
\fig{fig/dbhello.png}{height=0.5\textheight}

In \seco\ current storage db available via variable \verb$niche$

\clearpage
New database will be created in \verb$C:/Java/seco/dbHello:$
\begin{verbatim}
C:\Java\seco> ls -la dbHello
total 53
drwxr-xr-x 2 ponyatov   4096 May 24 03:18 .
drwxr-xr-x 5 ponyatov   4096 May 24 03:18 ..
-rw-r--r-- 1 ponyatov  44281 May 24 03:18 00000000.jdb
-rw-r--r-- 1 ponyatov     41 May 24 03:18 hgdbversion
-rw-r--r-- 1 ponyatov      0 May 24 03:18 je.info.0
-rw-r--r-- 1 ponyatov      0 May 24 03:18 je.info.0.lck
-rw-r--r-- 1 ponyatov      0 May 24 03:18 je.lck
\end{verbatim}

\hgdb\ can hold any \java\ object, for example we can put string into db and get
it from db:
\begin{verbatim}
db.get(db.add("Hello"));
Hello
\end{verbatim}

\begin{description}[nosep]
\item[HGHandle db.add(Object)]\ \\
returns \verb$HGHandle$ references to added object in database
\begin{framed}\noindent
\hgdb\ is full-fledged \term{object-oriented database}\\
able to store \emph{any} (serializable) \java\ \emph{objects}
\end{framed}
\item[Object db.get(HGHandle)]\ \\
returns object stored in db by it's handle
\item[db.close()]\ \\
in real applications don't forget to close db before exit\\
add this line to end of \verb$HyperGraphDB$ tab\\
and run this cell before exit from \seco
\begin{verbatim}
db.close();

null
\end{verbatim}
\end{description}

\secrel{Custom User Types}

\hgdb\ has a powerful and highly customizable type system that can represent any
\java\ type, but custom type interfacing details can be confusing. The good news
is that you don't need to fiddle with custom type implementations at all,
as long as you define your classes according to the \java$Bean$ standard:
\begin{itemize}[nosep]
\item your class must provide a \term{null-argument-constructor} and
\item \emph{each property} must have a \term{getter} and \term{setter}:
\end{itemize}
\lstx{sample integratable
\file{HGCustomClass}.java}{src/HGCustomClass.java}{Java}

For example let's see custom class sample from
\href{https://github.com/hypergraphdb/hypergraphdb/wiki/GettingStarted}{tutorial}.
\lstx{add this beanshell code to notebook}{src/HGBook.beanshell}{Java}

\clearpage
\secrel{Manupulate data without handle\ --- query basics}

Querying can be done by using the static helper class "hg":
\begin{verbatim}
import org.hypergraphdb.HGQuery.hg.*;
\end{verbatim}

We stored only one element in our database, so we can find it using query by
it's class:
\begin{verbatim}
HGQuery.hg.getAll(db, HGQuery.hg.type(String.class))

[Hello, Hello, Hello]
\end{verbatim}

Oops, we found more than one element\ --- this is because I played with
\verb$db$ many times, and added some strings with equal value, but they was
added as separate objects.

\clearpage
Sometimes it's more useful to get only handlers without transfer and deserialize
full objects (especially in case of large BLOBs):
\begin{verbatim}
HGQuery.hg.getAll(db, HGQuery.hg.type(String.class))

[47916675-b51e-46de-8aa6-a9d9ab428832, 
    6bba4ca0-31e1-4131-999c-f5720d6cde3b, 
        a4a59935-8864-438d-9c91-9bef0fc1a0f6]
\end{verbatim}

\clearpage
\secrel{Store data uniquely}

In case of need of object uniqality you should use \verb$assertAtom()$ function,
which precheck object already exists in db\note{database was recreated}:
\begin{verbatim}
db.get(HGQuery.hg.assertAtom(db,"Hello"));
db.get(HGQuery.hg.assertAtom(db,"Hello"));
HGQuery.hg.getAll(db, HGQuery.hg.type(String.class));

[Hello]
\end{verbatim}
Checking has it's price, so if you don't need unique \term{atom}s,
\verb$graph.add$ is faster.

\secrel{Terminology}

You just see new term\ --- \term{atom}. It's time to speak about hypergraphs.
\hgdb, as you see from it's name, uses hypergraphs for storing it's data. So far
we have considered \hgdb\ as an object database, but it's persistent memory
model goes from knowledge representation and AI, and uses \term{directed
hypergraph} formalism.

\secup